<!DOCTYPE html>
<html lang="en">

<head>
  <title>WAIT 2018</title>
  <meta charset="utf-8" />
  <meta http-equiv="X-UA-Compatible" content="IE=edge" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="description" content="" />
  <meta name="author" content="" />

  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" />
  <link href="../navbar-fixed-top.css" rel="stylesheet">
  <link href="../custom.css" rel="stylesheet">
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.1.1/jquery.min.js"></script>
  <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
  <link rel="icon" href="matryoshka_four_dolls.png">

  <style type="text/css">
.sticker table {
        border: 1px solid #666;
        margin: 20px 80px 2px 80px;
}

table.schedule {
  max-width: 55em;
}

table.schedule tr {
  background-color : #FFF;
}

table.schedule tr.break {
  background-color : #FFF;
}

table.schedule tr.session {
  background-color : #EEE;
}

table.schedule td:first-child {
  width : 7em;
  vertical-align: top;
}
  </style>
</head>

<body data-spy="scroll" data-target=".navbar">

<nav class="navbar navbar-default navbar-fixed-top">
  <div class="container">
    <div class="navbar-header">
      <a class="navbar-brand" href="#">WAIT 2018</a>
    </div>
    <ul class="nav navbar-nav">
      <li><a href="#Aim">Aim</a></li>
      <li><a href="#Venue">Venue</a></li>
      <li><a href="#Program">Program</a></li>
      <li><a href="#Participants">Participants</a></li>
      <li><a href="#Organizers">Organizers</a></li>
    </ul>
  </div>
</nav>

<div class="jumbotron">
  <div class="media-body">
    <table width=100%>
    <td width=400>
    <!-- <h1><font color="#1563b9">WAIT 2018</font></h1> -->
    <center><img src="wait2018_logo_480ppi.png" class="media-object" style="width:200px" alt="WAIT 2018"/></center>
    <td>
    <p><font size=6><b>Fourth&nbsp;International Workshop&nbsp;on Automated&nbsp;(Co)inductive Theorem&nbsp;Proving</b></font></p>
    <p><font size=5>28&ndash;29 June 2018, Amsterdam, The Netherlands
      <br>Co-located with <a href="../matryoshka2018/index.html"><b>Matryoshka 2018</b></a></font></p>
    </table>
  </div>
</div>

<div class="container" id="Aim">
  <div class="page-header">
    <h2>Aim</h2>
  </div>

<p>
Inductive and coinductive theorem proving is a topic of growing interest in
the automated reasoning community. The Fourth International Workshop on Automated
(Co)inductive Theorem Proving (WAIT 2018) focuses on all relevant aspects of
(co)inductive reasoning.

<p>
The workshop is an informal event and aims to give researchers interested in
the topic a chance to meet, exchange ideas, and have a platform for
discussions.

<p>
We invite talks featuring demonstrations and tutorials of (co)inductive
theorem provers, challenge problems, new directions of research, or anything
else of interest to the (co)inductive theorem proving community.

<p>
The previous events in the series were hosted in
<a href="https://www.doc.ic.ac.uk/~scd/InductThmPrv.pdf">London</a>,
<a href="http://www.cse.chalmers.se/~nicsma/induction/">Gothenburg</a>,
and
<a href="http://www.cse.chalmers.se/~laurako/grants/kaw_induction.html">Vienna</a>.
This fourth installment explicitly generalizes the scope to include
coinductive methods.

<p>
  Please send an email
  to the <a href="#Organizers">organizers</a> if you would like to give a
  talk, demonstrate a tool, or otherwise participate.

</div>

<div class="container" id="Venue">
  <div class="page-header">
    <h2>Venue</h2>
  </div>

  <p>
The workshop will take place on 28 and 29 June 2018 in the main building of
the Vrije Universiteit Amsterdam, room <a
href="https://www.vu.nl/nl/over-de-vu/campus/faciliteiten/overige-zalen/agora-zalen/index.aspx">Agora 3</a>.
The VU is easily accessible on foot from the Amsterdam Zuid station, a
short train ride away from Amsterdam Airport Schiphol. There are also parking
spaces. See <a
href="https://www.vu.nl/en/about-vu-amsterdam/contact-info-and-route/route-description/index.aspx">How
to get to VU Amsterdam</a> for details.
The workshop will start on 28 June at 09:00 and end on 29 June at 15:00.

<p>&nbsp;

<p><center>
<iframe src="https://www.google.com/maps/embed?pb=!1m18!1m12!1m3!1d2437.974178217828!2d4.864817431390582!3d52.334614540860166!2m3!1f0!2f0!3f0!3m2!1i1024!2i768!4f13.1!3m3!1m2!1s0x47c60a08ec0e1429%3A0x41c7ab5e6b913989!2sHoofdgebouw%2C+De+Boelelaan+1105%2C+1081+HV+Amsterdam!5e0!3m2!1sen!2snl!4v1525437971035" width="800" height="600" frameborder="0" style="border:0" allowfullscreen></iframe>
</center></p>

<p>&nbsp;

  <p>
WAIT 2018 will take place the same week as the <a
href="../matryoshka2018/index.html">First European Workshop on Higher-Order Automated
Reasoning (Matryoshka 2018)</a>.

  <p>
Hotels in Amsterdam can be very expensive. Even the cheapest options often
cost over 100 euros per night. The neighboring city of Amstelveen has more
reasonably priced options (e.g., Ibis) and is located close to the VU campus,
a few stops away by public transportation (tram line 5 or metro line&nbsp;51).

</div>

<div class="container" id="Program">
  <div class="page-header">
    <h2>Program</h2>
  </div>

  <table class="schedule">
    <tr>
      <td colspan="2">
        <h4>Thursday 28 June<br>&nbsp;</h4>
      </td>
    </tr>

    <tr class="session"><td></td><td><p>Session 1 (chair: Johannes Hölzl)</p></td></tr>

    <tr class="break"><td>09:00 &ndash; 09:05</td><td><p><b>Welcome</b></p></td></tr>

    <tr>
      <td>09:05 &ndash; 09:45</td>
      <td>
        <p>
          <b>Tree Grammars for Induction on Inductive Data Types modulo Equational Theories</b><br>
          Gabriel Ebner<br>
          Joint work with Stefan Hetzl<br>
          <a data-toggle="collapse" href="#collapseEbner" role="button" aria-expanded="false"
            aria-controls="collapseEbner">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Ebner-Tree-Grammars-for-Induction.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseEbner">
          Inductive theorem proving based on tree grammars was introduced by Eberhard and Hetzl in 2015. In
          this approach, proofs with induction on natural numbers are found by generalizing automatically
          generated proofs of finite instances on the level of Herbrand disjunctions. We extend this method to
          support general inductive data types, and reasoning modulo a background theory to abstract from
          irregularities in automatically generated proofs.  We present an experimental implementation of the
          method and show that it automatically produces non-analytic induction formulas for several examples.
        </p>
      </td>
    </tr>

    <tr>
      <td>09:45 &ndash; 10:30</td>
      <td>
        <p>
          <b>Finding Loop Invariants with QuickSpec (Work in Progress)</b><br>
          Nicholas Smallbone<br>
          <a data-toggle="collapse" href="#collapseSmallbone" role="button" aria-expanded="false"
            aria-controls="collapseSmallbone">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Smallbone-Finding-Loop-Invariants-with-QuickSpec.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseSmallbone">
          Recently I've been playing with using QuickSpec on imperative programs to discover loop
          invariants and similar assertions. I will talk about how I do it, as well as a crazy idea you
          can implement on top of it: psychic property-based testing.
        </p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Coffee break</b></p></td></tr>

    <tr class="session"><td></td><td><p>Session 2 (chair: Stefan Hetzl)</p></td></tr>

    <tr>
      <td>11:00 &ndash; 11:45</td>
      <td>
        <p><b>SMT-LIB 3: Bringing Higher-Order Logic to SMT</b><br>
          Pascal Fontaine<br>
          Joint work with Clark Barrett and Cesare Tinelli<br>
          <a data-toggle="collapse" href="#collapseFontaine" role="button" aria-expanded="false"
            aria-controls="collapseFontaine">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Fontaine-SMT-LIB-TIP.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseFontaine">
        I will first present the recent advances in SMT-LIB, and the future
        directions. I will also review the TIP format, and quickly discuss the
        features that have been imported into SMT-LIB, and those that aren't
        yet. We (the SMT-LIB managers) are keen to get input and feedback from
        the community, so I will be happy if the talk quickly becomes an open
        discussion about the nice features you want, the restrictions you
        hate, and get suggestions to make SMT-LIB an even more solid, clean,
        and clear standard for your problems.<br><br>
        Clark Barrett, Pascal Fontaine and Cesare Tinelli are the current SMT-LIB
        managers and are co-authors of this presentation (but Pascal will take all the
        blame for mistakes, e.g. misunderstanding TIP features).
        </p>
      </td>
    </tr>

    <tr>
      <td>11:45 &ndash; 12:30</td>
      <td>
        <p>
          <b>An Induction Principle for Automated Induction</b><br>
          Koen Claessen<br>
          Joint work with Linnea Andersson and Andres Wahlström<br>
          <a data-toggle="collapse" href="#collapseClaessen" role="button" aria-expanded="false"
            aria-controls="collapseClaessen">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Claessen-Induction-Principle-for-Automated-Induction.pdf">(slides)</a>
          <a href="https://docs.google.com/presentation/d/1y9btn2ryIrBc-NG8UgsE555rVE9HvGSQemiSfmiqPMc/edit?usp=sharing">(link)</a>
        </p>
        <p class="collapse" id="collapseClaessen">
          We explore alternatives to structural induction for use in automated induction. Our main
          candidate is a generalization of recursion induction.
        </p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Lunch break</b></p></td></tr>

    <tr class="session"><td></td><td><p>Session 3 (chair: Andrei Popescu)</p></td></tr>

    <tr>
      <td>14:00 &ndash; 14:45</td>
      <td>
        <p><b>Putting Theory Exploration to Work</b><br>
          Moa Johansson<br>
          <a data-toggle="collapse" href="#collapseJohansson" role="button" aria-expanded="false"
            aria-controls="collapseJohansson">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Johansson-Putting-Theory-Exploration-to-Work.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseJohansson">
        I will give a brief introduction to the theory exploration system
        Hipster, which discovers and proves lemmas by induction automatically.
        There will be a simple demo on some small examples, followed by a more
        speculative part where I'll invite to discussion on what is needed to
        make theory exploration tools efficient, stable and general enough to
        be of real use in e.g. a proof assistant.
        </p>
      </td>
    </tr>

    <tr>
      <td>14:45 &ndash; 15:30</td>
      <td>
        <p>
          <b>Theory Exploration for Coinduction</b><br>
          Sólrún Halla Einarsdóttir<br>
          Joint work with Moa Johansson and Johannes Åman Pohjola<br>
          <a data-toggle="collapse" href="#collapseEinarsdóttir" role="button" aria-expanded="false"
            aria-controls="collapseEinarsdóttir">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Einarsdottir-Theory-Exploration-for-Coinduction.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseEinarsdóttir">
          We have extended theory exploration to discover coinductive lemmas about corecursive
          (co)datatypes and functions. This required new methods for testing infinite values and for
          automated coinductive proofs. Our extension has been implemented in the Hipster theory
          exploration system for the proof assistant Isabelle/HOL.
        </p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Coffee break</b></p></td></tr>

    <tr class="session"><td></td><td><p>Session 4 (chair: Ekaterina Komendantskaya)</p></td></tr>

    <tr>
      <td>16:00 &ndash; 16:40</td>
      <td>
        <p>
          <b>Recursive Proofs for Coinductive Predicates</b><br>
          Henning Basold<br>
          <a data-toggle="collapse" href="#collapseBasold" role="button" aria-expanded="false"
            aria-controls="collapseBasold">
            (abstract)
          </a>
          <!--<a href="slides/WAIT-2018-Basold-Recursive Proofs for Coinductive Predicates.pdf">(slides)</a>-->
        </p>
        <p class="collapse" id="collapseBasold">
          We will discuss in this talk how to extend logics with the so-called later modality, which
          allows us to construct recursive proofs for arbitrary coinductive predicates. The later modality
          enables goal-directed proof discovery and the use any up-to technique that is provably
          compatible in the underlying logic. Often, we find that the resulting proof system also admits
          induction, either because of the nature of the coinductive predicate or through an up-to
          technique.
        </p>
      </td>
    </tr>

    <tr>
      <td>16:40 &ndash; 17:10</td>
      <td>
        <p>
          <b>Mechanically Certifying Formula-Based Noetherian Induction Reasoning</b><br>
          Sorin Stratulat<br>
          <a data-toggle="collapse" href="#collapseStratulat" role="button" aria-expanded="false"
            aria-controls="collapseStratulat">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Stratulat-Mechanically-Certifying-Formula-Based-Noetherian-Induction-Reasoning.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseStratulat">
        I describe general formal tools for certifying formula-based
        Noetherian induction proofs by Coq, then show how to apply them to
        certify cyclic proofs of conjectures about conditional specifications.
        The certification methodology can be easily adapted to automatically
        certify proofs built with a reductive rewrite-based inference system
        and, more generally, any formula-based Noetherian induction reasoning.
        </p>
      </td>
    </tr>

    <tr>
      <td>17:10 &ndash; 17:40</td>
      <td>
        <p>
          <b>What Are the Suitable Data Types for Syntax with Bindings?</b><br>
          Andrei Popescu<br>
          Joint work with Jasmin Blanchette, Lorenzo Gheri, and Dmitriy Traytel<br>
          <a data-toggle="collapse" href="#collapsePopescu1" role="button" aria-expanded="false"
            aria-controls="collapsePopescu1">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Popescu-Binding-Recursion.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapsePopescu1">
          Syntax with bindings is notoriously difficult to formalize and reason about in proof assistants.
          A main cause for this is the difficulty to characterize syntax with bindings by means of abstract
          data types in a useful way, so as to provide high-level structural induction and recursion principles.
          I will discuss some approaches to address this problem, including a recent line of work pursued in
          Isabelle/HOL together with colleagues.
        </p>
      </td>
    </tr>

<!--
    <tr>
      <td>16:45 &ndash; 17:00</td>
      <td>
        <p>
          <b>Ahead of Its Time: The Edinburgh Pure Lisp Theorem Prover</b><br>
          Jasmin Blanchette<br>
          Work by J Strother Moore and Robert S. Boyer, with contributions by Grant O. Passmore<br>
          <a data-toggle="collapse" href="#collapseBlanchette" role="button" aria-expanded="false"
            aria-controls="collapseBlanchette">
            (abstract)
          </a>
          <a href="slides/WAIT-2018--.pdf">(slides)</a>
          <a href="http://www.cs.utexas.edu/users/moore/best-ideas/pltp/index.html">(online archive)</a>
        </p>
        <p class="collapse" id="collapseBlanchette">
          Boyer and Moore's Pure Lisp Theorem Prover (PLTP) could prove <tt>rev (rev
          xs) = xs</tt> fully automatically already in 1973, without any lemmas.
          Many of the techniques that make ACL2 powerful were present in PLTP
          already. Recently, Passmore reimplemented PLTP in OCaml. Sadly, much of
          this line of work is poorly known on this side of the Atlantic.
        </p>
      </td>
    </tr>
-->

    <tr>
      <td>17:40 &ndash; 18:00</td>
      <td>
        <p><b>Wrap-up</b></p>
      </td>
    </tr>

    <br>
    <tr class="break"><td>19:30 &ndash; </td><td><p><b>Workshop dinner</b><br><a href="https://restaurantrozengeur.nl">Rozengeur</a> (Iranian cuisine)</p></td></tr>

    <tr>
      <td colspan="2">
        <h4><br>Friday 29 June<br>&nbsp;</h4>
      </td>
    </tr>

    <tr class="session"><td></td><td><p>Session 5 (chair: Henning Basold)</p></td></tr>

    <tr>
      <td>09:00 &ndash; 09:45</td>
      <td>
        <p>
          <b>Towards Coinductive Theory Exploration in Horn Clause Logic</b><br>
          Ekaterina Komendantskaya<br>
          <a data-toggle="collapse" href="#collapseKomendantskaya" role="button" aria-expanded="false"
            aria-controls="collapseKomendantskaya">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Komendantskaya-Towards-Coinductive-Theory-Exploration-in-Horn-Clause-Logic.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseKomendantskaya">
          Coinduction occurs in two guises in Horn clause logic: in proofs of self-referencing properties
          and relations, and in proofs involving construction of infinite data. Both instances of
          coinductive reasoning appeared in the literature before, but a systematic analysis of these two
          kinds of proofs and of their relation was lacking. We propose a general proof-theoretic
          framework for handling both kinds of coinduction arising in Horn clause logic. To this aim, we
          propose a coinductive extension of Miller et al’s framework of uniform proofs which we then use
          as a machinery for formulating and proving coinductive invariants required in proofs with
          first-order Horn clause logic.
        </p>
      </td>
    </tr>

    <tr>
      <td>
        <p>09:45 &ndash; 10:30</p>
      </td>
      <td>
        <p>
          <b>Finite and Infinite Traces, Inductively and Coinductively</b><br>
          Jurriaan Rot<br>
          <a data-toggle="collapse" href="#collapseRot" role="button" aria-expanded="false"
            aria-controls="collapseRot">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Rot-Finite-and-Infinite-Traces,-Inductively-and-Coinductively.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseRot">
        It is a well-known fact (used e.g. in model checking) that, on finitely
        branching transition systems, finite trace equivalence coincides with infinite
        trace equivalence. I will show how to prove this coinductively, which is
        arguably nicer than the standard inductive proof.
        </p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Coffee break</b></p></td></tr>

    <tr class="session"><td></td><td><p>Session 6 (chair: Sorin Stratulat)</p></td></tr>

    <tr>
      <td>11:00 &ndash; 11:45</td>
      <td>
        <p>
          <b>Cyclic Superposition and Induction</b><br>
          Jannik Vierling<br>
          <a data-toggle="collapse" href="#collapseVierling" role="button" aria-expanded="false"
            aria-controls="collapseVierling">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Vierling-Cyclic-Superposition-and-Induction.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseVierling">
          In 2013 Kersani and Peltier introduced the n-clause calculus, a
          superposition calculus enriched with a cycle detection rule realizing a
          form of reasoning by mathematical induction. Until now it is not known
          which form of induction is captured by the n-clause calculus. An upper
          bound in terms of the quantifier complexity of the induction invariant
          can be obtained by a two step translation: in a first step we encode
          cyclic refutations in a cyclic sequent calculus introduced by
          Brotherston and Simpson in 2010; in a second step we translate cyclic
          proofs into inductive LK proofs.
        </p>
      </td>
    </tr>

    <tr>
      <td>11:45 &ndash; 12:30</td>
      <td>
        <p>
          <b>Superposition with Datatypes and Codatatypes</b><br>
          Simon Robillard<br>
          Joint work with Jasmin Blanchette and Nicolas Peltier<br>
          <a data-toggle="collapse" href="#collapseRobillard" role="button" aria-expanded="false"
            aria-controls="collapseRobillard">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Robillard-Superposition-with-Datatypes-and-Codatatypes.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapseRobillard">
          The absence of a finite axiomatization of the first-order theory of datatypes and
          codatatypes represents a challenge for automatic theorem provers. We present two approaches to
          reason by saturation in this theory: one is a conservative theory extension with a finite number
          of axioms; the other is an extension of the superposition calculus, in conjunction with axioms.
        </p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Lunch break</b></p></td></tr>

    <tr class="session"><td></td><td><p>Session 7 (chair: Jasmin Blanchette)</p></td></tr>

    <tr>
      <td>14:00 &ndash; 14:30</td>
      <td>
        <p>
          <b>Friendly Corecursion in Isabelle/HOL</b><br>
          Andrei Popescu<br>
          Joint work with Jasmin Blanchette, Aymeric Bouzy, Andreas Lochbihler, and Dmitriy Traytel<br>
          <a data-toggle="collapse" href="#collapsePopescu2" role="button" aria-expanded="false"
            aria-controls="collapsePopescu2">
            (abstract)
          </a>
          <a href="slides/WAIT-2018-Popescu-Friendly-Corecursion.pdf">(slides)</a>
        </p>
        <p class="collapse" id="collapsePopescu2">
          Corecursion is a mechanism for defining functions that produce infinite
          objects such as streams, lazy lists and infinite-depth trees.
          Establishing corecursion schemes that are expressive, sound and
          automatic is a notoriously hard problem. I will discuss an approach,
          implemented in the proof assistant Isabelle/HOL, for training a
          logical system to learn stronger and stronger schemes on a sound basis.
          The central notion is that of a friendly operator (or friend), which
          constitutes a statically safe context for corecursive calls. The framework relies
          on the ability to recognize friends quasi-automatically by verifying
          relational parametricity conditions. I will also discuss some ideas on how
          to go beyond statically safe contexts with the price of mild dynamic checks.
        </p>
      </td>
    </tr>

    <tr>
      <td>14:30 &ndash; 15:00</td>
      <td>
        <p><b>Discussion</b></p>
      </td>
    </tr>

    <tr class="break"><td></td><td><p><b>Coffee break</b></p></td></tr>

  </table>

</div>

<div class="container" id="Participants">
  <div class="page-header">
    <h2>Participants</h2>
  </div>

<p>
  <a href="https://github.com/MaximilianAlgehed">Maximilian Algehed</a> (Chalmers Gothenburg)
<br>
  <a href="https://perso.ens-lyon.fr/henning.basold/thesis/workshop.html">Henning Basold</a>* (ENS Lyon)
<br>
  <a href="http://www.cs.vu.nl/~abp290/">Alexander Bentkamp</a> (VU Amsterdam)
<br>
  <a href="http://www.cs.vu.nl/~jbe248/">Jasmin Blanchette</a> (VU Amsterdam)
<br>
  <a href="http://profs.sci.univr.it/~bonacina/">Maria Paola Bonacina</a> (U. Verona)
<br>
  <a href="http://www.cse.chalmers.se/~koen/">Koen Claessen</a>* (Chalmers Gothenburg)
<br>
  <a href="https://martin.desharnais.me/">Martin Desharnais</a> (LMU M&uuml;nchen)
<br>
  <a href="https://gebner.org/">Gabriel Ebner</a>* (TU Wien)
<br>
  <a href="http://www.cse.chalmers.se/~slrn/">Sólrún Halla Einarsdóttir</a>* (Chalmers Gothenburg)
<br>
  <a href="https://www.linkedin.com/in/daniel-el-ouraoui-9a1ba1142/">Daniel El Ouraoui</a> (U. Lorraine and Inria Nancy)
<br>
  <a href="https://members.loria.fr/PFontaine/">Pascal Fontaine</a>* (U. Lorraine)
<br>
  <a href="http://dmg.tuwien.ac.at/hetzl/">Stefan Hetzl</a> (TU Wien)
<br>
  <a href="http://www.cs.vu.nl/~jhl890/">Johannes H&ouml;lzl</a> (VU Amsterdam)
<br>
  <a href="http://www.cse.chalmers.se/~jomoa/">Moa Johansson</a>* (Chalmers Gothenburg)
<br>
  <a href="http://www.macs.hw.ac.uk/~ek19/">Ekaterina Komendantskaya</a>* (Heriot-Watt U.)
<br>
  <a href="https://research.vu.nl/en/persons/pablo-le-henaff">Pablo Le H&eacute;naff</a> (&Eacute;cole Polytechnique Paris)
<br>
  <a href="http://robertylewis.com/">Robert Y. Lewis</a> (VU Amsterdam)
<br>
  <a href="http://andreipopescu.uk/">Andrei Popescu</a>** (Middlesex U.)
<br>
  <a href="https://www.cs.vu.nl/~femke/">Femke van Raamsdonk</a> (VU Amsterdam)
<br>
  <a href="https://www.logic.at/staff/riener/">Martin Riener</a> (U. Manchester)
<br>
  <a href="http://www.cse.chalmers.se/~simrob/">Simon Robillard</a>* (Chalmers Gothenburg)
<br>
  <a href="http://jurriaan.me/">Jurriaan Rot</a>* (RU Nijmegen)
<br>
  <a href="http://schurr.at">Hans-Jörg Schurr</a> (U. Lorraine and Inria Nancy)
<br>
  <a href="http://www.cse.chalmers.se/~nicsma/">Nicholas Smallbone</a>* (Chalmers Gothenburg)
<br>
  <a href="https://sites.google.com/site/sorinica/">Sorin Stratulat</a>* (U. Lorraine)
<br>
  <a href="https://github.com/jannikvierling">Jannik Vierling</a>* (TU Wien)
<br>
  <a href="https://github.com/petarvukmirovic">Petar Vukmirovi&cacute;</a> (VU Amsterdam)

<p>* speakers

</div>

<div class="container" id="Organizers">
  <div class="page-header">
    <h2>Organization</h2>
  </div>

  <a href="http://www.cs.vu.nl/~jbe248/">Jasmin Blanchette</a> (VU Amsterdam)
<br>
  <a href="http://www.cs.vu.nl/~jhl890/">Johannes H&ouml;lzl</a> (VU Amsterdam)

<br>
<br>
<br>

  <p>
  <b>Acknowledgment:</b> We want to thank Pascal Fontaine, Mojca Lovrencak,
  and Caroline Waij for helping with the organization.
  This workshop is partially supported by the ERC Starting Grant 2016 <a
  href="../index.html">Matryoshka</a> (grant agreement No.
  <a href="http://cordis.europa.eu/project/rcn/207590_en.html">713999</a>)
  and by the <a href="https://www.nwo.nl/financiering/onze-financieringsinstrumenten/ew/incidentele-steun/incidentele-steun.html">NWO incidentele steun</a> scheme.
  We kindly ask participants to mention the support from the ERC and the NWO
  in publications or in other kinds of scientific output that directly follows
  from the workshop. (The NWO would also like to receive a copy of the relevant
  publications.)

  <br>
  <br>
  <br>
    <div class="sticker">
      <table>
        <tbody><tr>
          <td>&nbsp;
          <td><img src="http://ec.europa.eu/research/participants/docs/h2020-funding-guide/imgs/eu-flag.jpg" width="50px" border="0" name="European Union flag"></td>
          <td>&nbsp;&nbsp;&nbsp;
          <td>This project has received funding from the European Union's Horizon 2020 research and innovation program
            under grant agreement No. 713999.&nbsp;&nbsp;</td>
        </tr>
      </tbody></table>
    </div>

  <br>
  <br>
  <br>

</div>

</body>

</html>
